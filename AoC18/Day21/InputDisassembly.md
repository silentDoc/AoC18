# Input disassembly
The same approach as day 19 part 2 is followed

## Declarations

`#ip 1` - Bind the instruction pointer to `r[1]`.

Later on `r[1]` will be annotated with `r<1>` instead to signalize that it is bound to the instruction pointer.

## Program

|  # |  Instruction        |  Pseudocode                   | Registers                       | ipAfter | Comments                  |
|---:|:--------------------|:------------------------------|:--------------------------------|:--------|---------------------------|
| 0  | `seti 123 0 3`      | r[3] = 123                    | [x, 0, 0, 123, 0, 0]            | 1       |                           |
| 1  | `bani 3 456 3`      | r[3] = r[3] & 456             | [x, 1, 0, 72 , 0, 0]            | 2       |                           |
| 2  | `eqri 3 72 3`       | r[3] = (r[3] == 72) ? 1 : 0   | [x, 2, 0,  1 , 0, 0]            | 3       | `Check r[3] == 72`        |
| 3  | `addr 3 1 1`        | r<1> = r<1> + r[3]            | [x, 3/4, 0,  1 , 0, 0]          | 4/5     | `No  - Jmp 4, Yes - Jmp 5`|
| 4  | `seti 0 0 1`        | r<1> = 0  ; jmp 1             | [x, 0, 0,  1 , 0, 0]            | 1       | `Jump to 1`               |
| 5  | `seti 0 1 3`        | r[3] = 0                      | [x, 5, 0,  0 , 0, 0]            | 6       |                           |
| 6  | `bori 3 65536 2`    | r[2] = r[3] | 65536           | [x, 6, 65536, 0 , 0, 0]         | 8       | `r[2] = 65536`            |
| 7  | `seti 1505483 6 3`  | r[3] = 1505483                | [x, 7, 65536, 1505483 , 0, 0]   | 9       | `r[3] = 1505483`          |
| 8  | `bani 2 255 4`      | r[4] = r[2] & 255             | [x, 8, 65536, 1505483 , 8, 0]   | 10      | `r[4] = 8`                |
| 9  | `addr 3 4 3`        | r[3] = r[3] + r[4]            | [x, 9 , 65536, 1505491 , 8, 0]  | 11      | `r[3] = 1505491`          |
| 10 | `bani 3 16777215 3` | r[3] = r[3] & 16777215        | [x, 10, 65536, 1505491 , 8, 0]  | 12      |                           |
| 11 | `muli 3 65899 3`    | r[3] = r[3] * 65899           | [x, 11, 65536, 426103601 , 8, 0]| 13      | `r[3] = 426103601`        |
| 12 | `bani 3 16777215 3` | r[3] = r[3] & 16777215        | [x, 12, 65536, 6673201, 8, 0]   | 14      | `r[3] = 6673201`          |
| 13 | `gtir 256 2 4`      | r[4] = (256 > r[2]) ? 1 : 0   | [x, 13, 65536, 6673201, 0, 0]   | 15      | `Check 256 > r[2]`        |
| 14 | `addr 4 1 1`        | r<1> = r<1> + r[4]            | [x, 14/15, 65536, 6673201, 0, 0]| 16/17   | `Yes - Jmp to 16`         |
| 15 | `addi 1 1 1`        | r<1> = r<1> + 1               | [x, 16, 65536, 6673201, 0, 0]   | 17      | `No - Jmp to 17`          |
| 16 | `seti 27 6 1`       | r<1> = 27                     | [x, 27, 65536, 6673201, 0, 0]   | 28      | `Yes - Jmp to 28 (2 jmps)`|
| 17 | `seti 0 3 4`        | r[4]  = 0                     | [x, 17, 65536, 6673201, 0, 0]   | 18      |                           |
| 18 | `addi 4 1 5`        | r[5]  = r[5] + 4              | [x, 18, 65536, 6673201, 0, 4]   | 19      |                           |
| 19 | `muli 5 256 5`      | r[5]  = r[5] * 256            | [x, 19, 65536, 6673201, 0, 1024]| 20      |                           |
| 20 | `gtrr 5 2 5`        | r[5] = (r[5] > r[2]) ? 1 : 0  | [x, 20, 65536, 6673201, 0, 1/0] | 21      | `Check r[5] > r[2]`       |
| 21 | `addr 5 1 1`        | r<1> = r[5] + r<1>            | [x, 21/22, 65536, 6673201, 0, 0]| 22/23   | `Yes - Jmp to 23`         |
| 22 | `addi 1 1 1`        | r<1> = r<1> + 1               | [x, 24, 65536, 6673201, 0, 0]   | 25      | `No - Jmp to 24`          |
| 23 | `seti 25 4 1`       | r<1> = 25                     | [x, 25, 65536, 6673201, 0, 1]   | 26      | `Yes - Jmp to 26`         |
| 24 | `addi 4 1 4`        | r[4] = r[4] + 4               | [x, 24, 65536, 6673201, 4, 0]   | 25      | `r[4] = 4`                |
| 25 | `seti 17 3 1`       | r<1> = 17                     | [x, 17, 65536, 6673201, 4, 0]   | 18      | `Jmp to 18`               |
| 26 | `setr 4 1 2`        | r[2] = r[4]                   | [x, 26, 0, 6673201, 4, 0]       | 27      |                           |
| 27 | `seti 7 4 1`        | r<1> = 7                      | [x, 7, 0, 6673201, 4, 0]        | 8       | `Jmp to 8`                |
| 28 | `eqrr 3 0 4`        | r[4] = (r[3] == r[0]) ? 1 : 0 | [x, 28, 65536, 6673201, 0/1, 0] | 29      | `Check r[3] = r[0] Only place!`  |
| 20 | `addr 4 1 1`        | r<1> = r[4] + r<1>            | [x, 29/30, 65536, 6673201, 0, 0]| 30/31   | `Halts if equal`          |
| 30 | `seti 5 9 1`        | r<1> = 5                      | [x, 5, 65536, 6673201, 0, 0]    | 6       | `Jmp to 6 if not equal`   |


## Conclusion

*Part 1* 
There is only one check done with R[0] (ins 28) - I will run the program and print the value of r[3] in that given moment
